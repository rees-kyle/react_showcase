"use strict";(self.webpackChunkproject=self.webpackChunkproject||[]).push([[266],{6266:(e,n,r)=>{r.r(n),r.d(n,{default:()=>x});var t=r(579);const s=()=>(0,t.jsxs)("div",{children:[(0,t.jsx)("h1",{className:"underline",children:"Error Handling And Loading States"}),(0,t.jsx)("p",{children:"To implement error handling and loading states effectively during API interactions, here are the main approaches you might consider, especially in React."})]});var o=r(5043);const i={spinnerContainer:{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",padding:"2.5rem"},spinner:{marginLeft:"1rem",width:"2.5rem",height:"2.5rem",border:"0.25rem solid #ccc",borderTop:"0.25rem solid #007bff",borderRadius:"50%",animation:"spin 1s linear infinite"}},a=document.styleSheets[0];a.insertRule("@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}",a.cssRules.length);const d=()=>(0,t.jsxs)("div",{style:i.spinnerContainer,children:[(0,t.jsx)("div",{style:i.spinner}),(0,t.jsx)("p",{children:"Loading..."})]}),l=()=>(0,t.jsxs)("div",{style:{textAlign:"center",padding:"20px"},children:[(0,t.jsx)("h2",{children:"Data Successfully Loaded!"}),(0,t.jsx)("p",{children:"This is the content you see after loading finishes."})]}),c=()=>{const[e,n]=(0,o.useState)(!0);return(0,o.useEffect)((()=>{n(!0),new Promise((e=>{setTimeout((()=>{e("Data fetched")}),2e3)})).then((()=>n(!1))).catch((()=>n(!1)))}),[]),(0,t.jsxs)("div",{children:[(0,t.jsx)("br",{}),(0,t.jsx)("hr",{}),(0,t.jsx)("h2",{children:"Loading State"}),(0,t.jsx)("p",{children:"Feedback is given to the user during data fetching by displaying a loading spinner or placeholder."}),(0,t.jsx)("p",{children:"A loading state variable controls whether the spinner or actual content is shown, updating once the fetch is complete."}),(0,t.jsx)("h3",{children:"Code:"}),(0,t.jsx)("pre",{children:(0,t.jsx)("code",{children:"// LoadingSpinner.js\nconst LoadingSpinner = () => {\n  return (\n    <div style={styles.spinnerContainer}>\n      <div style={styles.spinner}></div>\n      <p>Loading...</p>\n    </div>\n  );\n};\n\nconst styles = {\n  spinnerContainer: {\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n    padding: '2.5rem',\n  },\n  spinner: {\n    marginLeft: '1rem',\n    width: '2.5rem',\n    height: '2.5rem',\n    border: '0.25rem solid #ccc',\n    borderTop: '0.25rem solid #007bff',\n    borderRadius: '50%',\n    animation: 'spin 1s linear infinite',\n  },\n};\n\nconst styleSheet = document.styleSheets[0];\nconst keyframes =\n`@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}`;\nstyleSheet.insertRule(keyframes, styleSheet.cssRules.length);\n\nexport default LoadingSpinner;\n"})}),(0,t.jsx)("br",{}),(0,t.jsx)("pre",{children:(0,t.jsx)("code",{children:"// DataContent.js\nconst DataContent = () => {\n  return (\n    <div style={{ textAlign: 'center', padding: '20px' }}>\n      <h2>Data Successfully Loaded!</h2>\n      <p>This is the content you see after loading finishes.</p>\n    </div>\n  );\n};\n\nexport default DataContent;\n"})}),(0,t.jsx)("br",{}),(0,t.jsx)("pre",{children:(0,t.jsx)("code",{children:"// LoadingState.js\nimport { useEffect, useState } from 'react';\nimport LoadingSpinner from './LoadingSpinner';\nimport DataContent from './DataContent';\n\nconst fetchData = () => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('Data fetched');\n    }, 2000); // Simulate 2 seconds delay\n  });\n};\n\nconst LoadingState = () => {\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    setLoading(true);\n\n    fetchData()\n      .then(() => setLoading(false))\n      .catch(() => setLoading(false));\n  }, []);\n\n\n  return (\n    <div>\n      {loading ? <LoadingSpinner /> : <DataContent />}\n    </div>\n  );\n};\n\nexport default LoadingState;\n"})}),(0,t.jsx)("h3",{children:"Output:"}),e?(0,t.jsx)(d,{}):(0,t.jsx)(l,{})]})},h={errorContainer:{textAlign:"center",padding:"1.25rem",backgroundColor:"#f1f1f1",borderRadius:"0.3125rem",color:"#333",boxShadow:"0 4px 8px rgba(0, 0, 0, 0.1)"},errorText:{fontSize:"1.125rem",fontWeight:"bold",color:"#e53935"},errorDetails:{marginBottom:"1.25rem",color:"#666"},retryButton:{padding:"0.625rem 1.25rem",backgroundColor:"#007bff",color:"#fff",border:"none",borderRadius:"0.3125rem",cursor:"pointer",transition:"background-color 0.3s"}};h.retryButton[":hover"]={backgroundColor:"#0056b3"};const p=e=>{let{message:n,onRetry:r}=e;return(0,t.jsxs)("div",{style:h.errorContainer,children:[(0,t.jsx)("h2",{style:h.errorText,children:"Oops! Something went wrong."}),(0,t.jsx)("p",{style:h.errorDetails,children:n}),(0,t.jsx)("button",{type:"button",style:h.retryButton,onClick:r,children:"Retry"})]})},g=()=>{const[e,n]=(0,o.useState)(!0),[r,s]=(0,o.useState)(null),[i,a]=(0,o.useState)(null),c=async()=>{n(!0),s(null);try{const e=await fetch("https://invalid-url.com/");if(!e.ok)throw new Error("Failed to fetch data");const n=await e.json();a(n)}catch(e){s(e.message)}finally{n(!1)}};return(0,o.useEffect)((()=>{c()}),[]),(0,t.jsxs)("div",{children:[(0,t.jsx)("br",{}),(0,t.jsx)("hr",{}),(0,t.jsx)("h2",{children:"Error Handling"}),(0,t.jsx)("p",{children:"Gracefully handling errors improves the user experience by providing clear messages when something goes wrong. Using an error state variable allows you to track issues and show helpful feedback."}),(0,t.jsx)("p",{children:"When an error occurs, you can display a message and offer a retry option. This helps users understand the issue and gives them a chance to fix it, making the app more user-friendly."}),(0,t.jsx)("h3",{children:"Code:"}),(0,t.jsx)("pre",{children:(0,t.jsx)("code",{children:"// ErrorMessage.js\nconst ErrorMessage = ({ message, onRetry }) => {\n  return (\n    <div style={styles.errorContainer}>\n      <h2 style={styles.errorText}>Oops! Something went wrong.</h2>\n      <p style={styles.errorDetails}>{message}</p>\n      <button type=\"button\" style={styles.retryButton} onClick={onRetry}>Retry</button>\n    </div>\n  );\n};\n\nconst styles = {\n  errorContainer: {\n    textAlign: 'center',\n    padding: '1.25rem',\n    backgroundColor: '#f1f1f1', \n    borderRadius: '0.3125rem',\n    color: '#333', \n    boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',\n  },\n  errorText: {\n    fontSize: '1.125rem',\n    fontWeight: 'bold',\n    color: '#e53935',\n  },\n  errorDetails: {\n    marginBottom: '1.25rem',\n    color: '#666',\n  },\n  retryButton: {\n    padding: '0.625rem 1.25rem',\n    backgroundColor: '#007bff',\n    color: '#fff',\n    border: 'none',\n    borderRadius: '0.3125rem',\n    cursor: 'pointer',\n    transition: 'background-color 0.3s',\n  },\n};\n\nstyles.retryButton[':hover'] = {\n  backgroundColor: '#0056b3',\n};\n\nexport default ErrorMessage;\n"})}),(0,t.jsx)("br",{}),(0,t.jsx)("pre",{children:(0,t.jsx)("code",{children:"// ErrorHandling.js\nimport React, { useState, useEffect } from 'react';\nimport LoadingSpinner from './LoadingSpinner';\nimport DataContent from './DataContent';\nimport ErrorMessage from './ErrorMessage';\n\nconst ErrorHandling = () => {\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n\n  const fetchData = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await fetch('https://invalid-url.com/');\n      if (!response.ok) throw new Error('Failed to fetch data');\n      \n      const data = await response.json();\n      setData(data);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return (\n    <div>\n      {loading ? (\n          <LoadingSpinner />\n      ) : error ? (\n          <ErrorMessage message={error} onRetry={fetchData} />\n      ) : (\n          <DataContent data={data} />\n      )}\n    </div>\n  );\n};\n\nexport default ErrorHandling;\n"})}),(0,t.jsx)("h3",{children:"Output:"}),e?(0,t.jsx)(d,{}):r?(0,t.jsx)(p,{message:r,onRetry:c}):(0,t.jsx)(l,{data:i})]})},u=()=>(0,t.jsxs)("div",{children:[(0,t.jsx)("br",{}),(0,t.jsx)("hr",{}),(0,t.jsx)("h2",{children:"Combine Loading and Error States"}),(0,t.jsx)("p",{children:"The goal is to improve the user experience by showing only one state at a time, making it clear whether the app is loading, has an error, or is ready to display content."}),(0,t.jsx)("h3",{children:"Code:"}),(0,t.jsx)("pre",{children:(0,t.jsx)("code",{children:"return (\n  <div>\n    {loading && <LoadingSpinner />}\n\n    {error && <ErrorMessage message={error} onRetry={fetchData} />}\n\n    {!loading && !error && <DataContent />}\n  </div>\n);\n"})}),(0,t.jsx)("br",{}),(0,t.jsx)("p",{children:"A loading spinner appears while the app fetches data. If there's an error, a message is shown to inform the user. Once the data is ready, the content is displayed."})]}),f=()=>(0,t.jsxs)("div",{children:[(0,t.jsx)("br",{}),(0,t.jsx)("hr",{}),(0,t.jsx)("h2",{children:"User-Friendly Elements"}),(0,t.jsx)("h3",{children:"Loading Indicator"}),(0,t.jsx)("p",{children:"A spinner or skeleton loader is helpful for loading states."}),(0,t.jsx)("h3",{children:"Error Retry Option"}),(0,t.jsx)("p",{children:"An option to retry the API call can improve usability, especially if the error could be transient."})]}),m=()=>(0,t.jsxs)("div",{children:[(0,t.jsx)("br",{}),(0,t.jsx)("hr",{}),(0,t.jsx)("h2",{children:"Summary"}),(0,t.jsx)("p",{children:"This setup makes API interactions in React user-friendly and resilient, addressing both the need for immediate feedback during loading and error handling if issues arise."})]}),x=()=>(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s,{}),(0,t.jsx)(c,{}),(0,t.jsx)(g,{}),(0,t.jsx)(u,{}),(0,t.jsx)(f,{}),(0,t.jsx)(m,{})]})}}]);
//# sourceMappingURL=266.16e31547.chunk.js.map