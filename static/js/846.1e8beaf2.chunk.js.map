{"version":3,"file":"static/js/846.1e8beaf2.chunk.js","mappings":"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","sources":["components/component_lifecycle/hooks/Hooks.js","components/component_lifecycle/hooks/ComponentLifecyclePhases.js","components/component_lifecycle/hooks/UseEffect.js","components/component_lifecycle/hooks/UseLayoutEffect.js","components/component_lifecycle/hooks/Demo.js","components/component_lifecycle/hooks/KeyDifferences.js","components/component_lifecycle/hooks/Summary.js","pages/component_lifecycle/HooksPage.js"],"sourcesContent":["const Hooks = () => {\r\n    return (\r\n        <div>\r\n            <h1 className=\"underline\">Hooks</h1>\r\n            <p>\r\n                React Hooks, such as 'useEffect' and 'useLayoutEffect', are used to control and interact with lifecycle phases in functional components.\r\n            </p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Hooks;","const ComponentLifecyclePhases = () => {\r\n    return (\r\n        <div>\r\n            <br/>\r\n            <hr/>\r\n            <h2>Component Lifecycle Phases Reminder</h2>\r\n            <h3>Mounting</h3>\r\n            <p>\r\n                When the component is initialized and added to the DOM.\r\n            </p>\r\n\r\n            <h3>Updating</h3>\r\n            <p>\r\n                When the component is re-rendered due to changes in state or props.\r\n            </p>\r\n\r\n            <h3>Unmounting</h3>\r\n            <p>\r\n                When the component is removed from the DOM.\r\n            </p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ComponentLifecyclePhases;","const UseEffect = () => {\r\n    return (\r\n        <div>\r\n            <br/>\r\n            <hr/>\r\n            <h2>'useEffect' Hook</h2>\r\n            <p>\r\n                'useEffect' allows you to perform side effects in function components.\r\n                It runs after the component renders and can optionally clean up when the component unmounts or before the next render.\r\n            </p>\r\n\r\n            <h3>Syntax</h3>\r\n            <pre>\r\n                <code>\r\n                    {`useEffect(() => {\r\n    // Your side-effect code here (like API calls, data fetching, etc.)\r\n\r\n    return () => {\r\n        // Clean up code (optional)\r\n    };\r\n}, [dependencies]);\r\n`}\r\n                </code>\r\n            </pre>\r\n\r\n            <h3>Process</h3>\r\n            <p>\r\n                The callback runs after the render.\r\n                The cleanup, if provided, runs when the component is unmounted or before the next effect.\r\n                The dependencies array tells React when to run the effect.\r\n                If it is empty, the effect runs only once, after the initial render.\r\n                If the array contains values, such as [prop, state], the effect runs whenever those values change.\r\n            </p>\r\n\r\n            <h3>Common Use Cases</h3>\r\n            <p>\r\n                Data fetching can be done after a component mounts, allowing you to load data dynamically.\r\n                Event listeners can be attached or cleaned up to handle events like user interactions.\r\n                Additionally, subscribing and unsubscribing to services or sockets ensures proper connection management,\r\n                enabling real-time data handling or communication within the component lifecycle.\r\n            </p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default UseEffect;","const UseLayoutEffect = () => {\r\n    return (\r\n        <div>\r\n            <br/>\r\n            <hr/>\r\n            <h2>'useLayoutEffect' Hook</h2>\r\n            <p>\r\n                'useLayoutEffect' is similar to 'useEffect' but differs in timing.\r\n                It runs synchronously after all DOM mutations but before the browser has painted the screen.\r\n                This is useful when you need to measure or adjust the DOM before it becomes visible to the user.\r\n            </p>\r\n\r\n            <h3>Syntax</h3>\r\n            <pre>\r\n                <code>\r\n                    {`useLayoutEffect(() => {\r\n    // DOM-related side-effects\r\n\r\n    return () => {\r\n        // Clean up code (optional)\r\n    };\r\n}, [dependencies]);\r\n`}\r\n                </code>\r\n            </pre>\r\n\r\n            <h3>Process</h3>\r\n            <p>\r\n                The callback in 'useLayoutEffect' runs synchronously after the render, but before the DOM is painted.\r\n                The cleanup, if provided, runs when the component is unmounted or before the next effect.\r\n                The dependencies array tells React when to run the effect. If it is empty, the effect runs only once, after the initial render.\r\n                If the array contains values, such as [prop, state], the effect runs whenever those values change.\r\n            </p>\r\n\r\n            <h3>Common Use Cases</h3>\r\n            <p>\r\n                'useLayoutEffect' is typically used for tasks that require DOM mutations or measurements before the browser paints the UI,\r\n                such as measuring element sizes or applying styles. It can also be useful for synchronously updating the layout,\r\n                preventing flickering or visual inconsistencies. Like 'useEffect',\r\n                it can be used for subscribing and unsubscribing to services or sockets,\r\n                but with the added benefit of executing synchronously before the UI is updated.\r\n            </p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default UseLayoutEffect;","import React, { useState, useEffect, useLayoutEffect, useRef } from \"react\";\r\n\r\nconst Demo = () => {\r\n  // State to hold the text content\r\n  const [text, setText] = useState(\"This is a span element.\");\r\n\r\n  // State to hold the width of the span element using useEffect\r\n  const [widthEffect, setWidthEffect] = useState(0);\r\n\r\n  // State to hold the width of the span element using useLayoutEffect\r\n  const [widthLayoutEffect, setWidthLayoutEffect] = useState(0);\r\n\r\n  // Reference to the span element to measure its width\r\n  const spanRef = useRef(null);\r\n\r\n  // useEffect hook to measure the width after the text changes\r\n  useEffect(() => {\r\n    if (spanRef.current) {\r\n      setWidthEffect(spanRef.current.offsetWidth); // Update widthEffect state with the span's width\r\n    }\r\n  }, [text]); // Only run when the 'text' state changes\r\n\r\n  // useLayoutEffect hook to measure the width after the text changes (runs synchronously)\r\n  useLayoutEffect(() => {\r\n    if (spanRef.current) {\r\n      setWidthLayoutEffect(spanRef.current.offsetWidth); // Update widthLayoutEffect state with the span's width\r\n    }\r\n  }, [text]); // Only run when the 'text' state changes\r\n\r\n  // Function to append text to the current text state when the button is clicked\r\n  const handleAppendText = () => {\r\n    setText(text + \" (appending)\"); // Append the string \"(appending)\" to the existing text\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <br />\r\n      <hr />\r\n      <h2>Demo</h2>\r\n      <p>\r\n        This demo shows how React's useEffect and useLayoutEffect hooks can be used to measure the width of a span element as its text content changes.\r\n        By appending text, you can see how these hooks measure the element’s width and react to the updates.\r\n      </p>\r\n\r\n      <h3>Code:</h3>\r\n      <pre>\r\n        <code>\r\n          {`import React, { useState, useEffect, useLayoutEffect, useRef } from \"react\";\r\n\r\nconst Demo = () => {\r\n  const [text, setText] = useState(\"This is a span element.\");\r\n  const [widthEffect, setWidthEffect] = useState(0);\r\n  const [widthLayoutEffect, setWidthLayoutEffect] = useState(0);\r\n  const spanRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (spanRef.current) {\r\n      setWidthEffect(spanRef.current.offsetWidth);\r\n    }\r\n  }, [text ]);\r\n\r\n  useLayoutEffect(() => {\r\n    if (spanRef.current) {\r\n      setWidthLayoutEffect(spanRef.current.offsetWidth);\r\n    }\r\n  }, [text]);\r\n\r\n  const handleAppendText = () => {\r\n    setText(text + \" (appending)\");\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={handleAppendText}>Append Text</button>\r\n      <br />\r\n      <span ref={spanRef}>\r\n        {text}\r\n      </span>\r\n      <h2 className=\"output\">Width (useEffect): {widthEffect}px</h2>\r\n      <h2 className=\"output\">Width (useLayoutEffect): {widthLayoutEffect}px</h2>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Demo;\r\n`}\r\n        </code>\r\n      </pre>\r\n      <br/>\r\n      <p>\r\n        In the code, useState stores the text and width values. The span element is referenced with useRef.\r\n        The useEffect hook measures the width after the component updates, while useLayoutEffect measures it immediately before the screen renders.\r\n        Both hooks track the width change when new text is added.\r\n      </p>\r\n\r\n      <h3>Output:</h3>\r\n      <button onClick={handleAppendText}>Append Text</button>\r\n      <br />\r\n      <span ref={spanRef}>\r\n        {text}\r\n      </span>\r\n      <h2 className=\"output\">Width (useEffect): {widthEffect}px</h2>\r\n      <h2 className=\"output\">Width (useLayoutEffect): {widthLayoutEffect}px</h2>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Demo;","const KeyDifferences = () => {\r\n    return (\r\n        <div>\r\n            <br/>\r\n            <hr/>\r\n            <h2>Key Differences</h2>\r\n            <h3>useEffect</h3>\r\n            <p>\r\n                For tasks that can happen after the render.\r\n            </p>\r\n\r\n            <h3>useLayoutEffect</h3>\r\n            <p>\r\n                For tasks that need to happen immediately after the render, especially when layout measurements or changes are required.\r\n            </p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default KeyDifferences;","const Summary = () => {\r\n    return (\r\n        <div>\r\n            <br/>\r\n            <hr/>\r\n            <h2>Summary</h2>\r\n            <p>\r\n                Use 'useEffect' for side effects that don’t affect layout or need to happen after the render,such as API calls, subscriptions, or logging,\r\n                while 'useLayoutEffect' is useful when you need to manipulate the DOM or perform measurements before the browser paints to prevent flickering.\r\n                These hooks help manage the lifecycle and effects in functional components efficiently, ensuring proper execution timing based on the component’s rendering phase.\r\n            </p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Summary;","import {\r\n  Hooks,\r\n  ComponentLifecyclePhases,\r\n  UseEffect,\r\n  UseLayoutEffect,\r\n  Demo,\r\n  KeyDifferences,\r\n  Summary\r\n} from '../../components/component_lifecycle/hooks';\r\n\r\nconst HooksPage = () => {\r\n  return (\r\n    <>\r\n      <Hooks />\r\n      <ComponentLifecyclePhases />\r\n      <UseEffect />\r\n      <UseLayoutEffect />\r\n      <Demo />\r\n      <KeyDifferences />\r\n      <Summary />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default HooksPage;"],"names":["Hooks","_jsxs","children","_jsx","className","ComponentLifecyclePhases","UseEffect","UseLayoutEffect","Demo","text","setText","useState","widthEffect","setWidthEffect","widthLayoutEffect","setWidthLayoutEffect","spanRef","useRef","useEffect","current","offsetWidth","useLayoutEffect","onClick","handleAppendText","ref","KeyDifferences","Summary","HooksPage","_Fragment"],"sourceRoot":""}