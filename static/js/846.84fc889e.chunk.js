"use strict";(self.webpackChunkproject=self.webpackChunkproject||[]).push([[846],{846:(e,t,n)=>{n.r(t),n.d(t,{default:()=>f});var s=n(579);const r=()=>(0,s.jsxs)("div",{children:[(0,s.jsx)("h1",{className:"underline",children:"Hooks"}),(0,s.jsx)("p",{children:"React Hooks, such as 'useEffect' and 'useLayoutEffect', are used to control and interact with lifecycle phases in functional components."})]}),c=()=>(0,s.jsxs)("div",{children:[(0,s.jsx)("br",{}),(0,s.jsx)("hr",{}),(0,s.jsx)("h2",{children:"Component Lifecycle Phases Reminder"}),(0,s.jsx)("h3",{children:"Mounting"}),(0,s.jsx)("p",{children:"When the component is initialized and added to the DOM."}),(0,s.jsx)("h3",{children:"Updating"}),(0,s.jsx)("p",{children:"When the component is re-rendered due to changes in state or props."}),(0,s.jsx)("h3",{children:"Unmounting"}),(0,s.jsx)("p",{children:"When the component is removed from the DOM."})]}),o=()=>(0,s.jsxs)("div",{children:[(0,s.jsx)("br",{}),(0,s.jsx)("hr",{}),(0,s.jsx)("h2",{children:"'useEffect' Hook"}),(0,s.jsx)("p",{children:"'useEffect' allows you to perform side effects in function components. It runs after the component renders and can optionally clean up when the component unmounts or before the next render."}),(0,s.jsx)("h3",{children:"Syntax"}),(0,s.jsx)("pre",{children:(0,s.jsx)("code",{children:"useEffect(() => {\n    // Your side-effect code here (like API calls, data fetching, etc.)\n\n    return () => {\n        // Clean up code (optional)\n    };\n}, [dependencies]);\n"})}),(0,s.jsx)("h3",{children:"Process"}),(0,s.jsx)("p",{children:"The callback runs after the render. The cleanup, if provided, runs when the component is unmounted or before the next effect. The dependencies array tells React when to run the effect. If it is empty, the effect runs only once, after the initial render. If the array contains values, such as [prop, state], the effect runs whenever those values change."}),(0,s.jsx)("h3",{children:"Common Use Cases"}),(0,s.jsx)("p",{children:"Data fetching can be done after a component mounts, allowing you to load data dynamically. Event listeners can be attached or cleaned up to handle events like user interactions. Additionally, subscribing and unsubscribing to services or sockets ensures proper connection management, enabling real-time data handling or communication within the component lifecycle."})]}),i=()=>(0,s.jsxs)("div",{children:[(0,s.jsx)("br",{}),(0,s.jsx)("hr",{}),(0,s.jsx)("h2",{children:"'useLayoutEffect' Hook"}),(0,s.jsx)("p",{children:"'useLayoutEffect' is similar to 'useEffect' but differs in timing. It runs synchronously after all DOM mutations but before the browser has painted the screen. This is useful when you need to measure or adjust the DOM before it becomes visible to the user."}),(0,s.jsx)("h3",{children:"Syntax"}),(0,s.jsx)("pre",{children:(0,s.jsx)("code",{children:"useLayoutEffect(() => {\n    // DOM-related side-effects\n\n    return () => {\n        // Clean up code (optional)\n    };\n}, [dependencies]);\n"})}),(0,s.jsx)("h3",{children:"Process"}),(0,s.jsx)("p",{children:"The callback in 'useLayoutEffect' runs synchronously after the render, but before the DOM is painted. The cleanup, if provided, runs when the component is unmounted or before the next effect. The dependencies array tells React when to run the effect. If it is empty, the effect runs only once, after the initial render. If the array contains values, such as [prop, state], the effect runs whenever those values change."}),(0,s.jsx)("h3",{children:"Common Use Cases"}),(0,s.jsx)("p",{children:"'useLayoutEffect' is typically used for tasks that require DOM mutations or measurements before the browser paints the UI, such as measuring element sizes or applying styles. It can also be useful for synchronously updating the layout, preventing flickering or visual inconsistencies. Like 'useEffect', it can be used for subscribing and unsubscribing to services or sockets, but with the added benefit of executing synchronously before the UI is updated."})]});var a=n(5043);n(3923);const h=()=>{const[e,t]=(0,a.useState)("This is a span element."),[n,r]=(0,a.useState)(0),[c,o]=(0,a.useState)(0),i=(0,a.useRef)(null);(0,a.useEffect)((()=>{i.current&&r(i.current.offsetWidth)}),[e]),(0,a.useLayoutEffect)((()=>{i.current&&o(i.current.offsetWidth)}),[e]);return(0,s.jsxs)("div",{children:[(0,s.jsx)("br",{}),(0,s.jsx)("hr",{}),(0,s.jsx)("h2",{children:"Demo"}),(0,s.jsx)("p",{children:"This demo shows how React's useEffect and useLayoutEffect hooks can be used to measure the width of a span element as its text content changes. By appending text, you can see how these hooks measure the element\u2019s width and react to the updates."}),(0,s.jsx)("h3",{children:"Code:"}),(0,s.jsx)("pre",{children:(0,s.jsx)("code",{children:'import React, { useState, useEffect, useLayoutEffect, useRef } from "react";\nimport \'./../../../button.css\';\n\nconst Demo = () => {\n  const [text, setText] = useState("This is a span element.");\n  const [widthEffect, setWidthEffect] = useState(0);\n  const [widthLayoutEffect, setWidthLayoutEffect] = useState(0);\n  const spanRef = useRef(null);\n\n  useEffect(() => {\n    if (spanRef.current) {\n      setWidthEffect(spanRef.current.offsetWidth);\n    }\n  }, [text ]);\n\n  useLayoutEffect(() => {\n    if (spanRef.current) {\n      setWidthLayoutEffect(spanRef.current.offsetWidth);\n    }\n  }, [text]);\n\n  const handleAppendText = () => {\n    setText(text + " (appending)");\n  };\n\n  return (\n    <div>\n      <button onClick={handleAppendText}>Append Text</button>\n      <br />\n      <span ref={spanRef}>\n        {text}\n      </span>\n      <h2 className="output">Width (useEffect): {widthEffect}px</h2>\n      <h2 className="output">Width (useLayoutEffect): {widthLayoutEffect}px</h2>\n    </div>\n  );\n};\n\nexport default Demo;\n'})}),(0,s.jsx)("br",{}),(0,s.jsx)("p",{children:"In the code, useState stores the text and width values. The span element is referenced with useRef. The useEffect hook measures the width after the component updates, while useLayoutEffect measures it immediately before the screen renders. Both hooks track the width change when new text is added."}),(0,s.jsx)("h3",{children:"Output:"}),(0,s.jsx)("button",{onClick:()=>{t(e+" (appending)")},children:"Append Text"}),(0,s.jsx)("br",{}),(0,s.jsx)("span",{ref:i,children:e}),(0,s.jsxs)("h2",{className:"output",children:["Width (useEffect): ",n,"px"]}),(0,s.jsxs)("h2",{className:"output",children:["Width (useLayoutEffect): ",c,"px"]})]})},u=()=>(0,s.jsxs)("div",{children:[(0,s.jsx)("br",{}),(0,s.jsx)("hr",{}),(0,s.jsx)("h2",{children:"Key Differences"}),(0,s.jsx)("h3",{children:"useEffect"}),(0,s.jsx)("p",{children:"For tasks that can happen after the render."}),(0,s.jsx)("h3",{children:"useLayoutEffect"}),(0,s.jsx)("p",{children:"For tasks that need to happen immediately after the render, especially when layout measurements or changes are required."})]}),d=()=>(0,s.jsxs)("div",{children:[(0,s.jsx)("br",{}),(0,s.jsx)("hr",{}),(0,s.jsx)("h2",{children:"Summary"}),(0,s.jsx)("p",{children:"Use 'useEffect' for side effects that don\u2019t affect layout or need to happen after the render,such as API calls, subscriptions, or logging, while 'useLayoutEffect' is useful when you need to manipulate the DOM or perform measurements before the browser paints to prevent flickering. These hooks help manage the lifecycle and effects in functional components efficiently, ensuring proper execution timing based on the component\u2019s rendering phase."})]}),f=()=>(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r,{}),(0,s.jsx)(c,{}),(0,s.jsx)(o,{}),(0,s.jsx)(i,{}),(0,s.jsx)(h,{}),(0,s.jsx)(u,{}),(0,s.jsx)(d,{})]})},3923:()=>{}}]);
//# sourceMappingURL=846.84fc889e.chunk.js.map